#include <bits/stdc++.h>

using namespace std;

/* grid

[ 	    x1,  x2,  x3           ]
[ 	    x4,  x5,  x6, x17, x18 ]
[ x10,  x7,  x8,  x9, x19, x20 ]
[ x11, x12, x13, x21, x22, x23 ]
[ x14, x15, x16, x24, x25      ]
[           x26, x27, x28      ]

[ x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15, x16, x17, x18, x19, x20, x21, x22, x23, x24, x25, x26, x27, x28 ]
[  1,  1,  1,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][z]
[  0,  0,  0,  1,  1,  1,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][z]
[  0,  0,  0,  0,  0,  0,  1,  1,  1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][z]
[  1,  0,  0,  1,  0,  0,  1,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][z]
[  0,  1,  0,  0,  1,  0,  0,  1,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][z]
[  0,  0,  1,  0,  0,  1,  0,  0,  1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][z]
[  1,  0,  0,  0,  1,  0,  0,  0,  1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][z]
[  0,  0,  1,  0,  1,  0,  1,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][z]

[  0,  0,  0,  0,  0,  0,  1,  1,  0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][y]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   1,   1,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][y]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   1,   1,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][y]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   1,   1,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][y]
[  0,  0,  0,  0,  0,  0,  1,  0,  0,   0,   0,   1,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][y]
[  0,  0,  0,  0,  0,  0,  0,  1,  0,   0,   0,   0,   1,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][y]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   1,   0,   1,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][y]
[  0,  0,  0,  0,  0,  0,  0,  1,  0,   0,   0,   1,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][y]

[  0,  0,  0,  0,  0,  1,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0 ][w]
[  0,  0,  0,  0,  0,  0,  0,  0,  1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0,   0,   0,   0 ][w]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   1,   0,   0,   0,   0,   0 ][w]
[  0,  0,  0,  0,  0,  1,  0,  0,  1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0 ][w]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   1,   0,   0,   1,   0,   0,   0,   0,   0,   0 ][w]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   1,   0,   0,   1,   0,   0,   0,   0,   0 ][w]
[  0,  0,  0,  0,  0,  1,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   1,   0,   0,   0,   0,   0 ][w]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   0,   1,   0,   0,   0,   0,   0,   0,   0 ][w]

[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   0,   0,   0,   0 ][q]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   1,   1,   0,   0,   0 ][q]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   1,   1 ][q]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   1,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0 ][q]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   1,   0,   0,   1,   0 ][q]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   1,   0,   0,   1 ][q]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   1,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   0,   0,   1 ][q]
[  0,  0,  0,  0,  0,  0,  0,  0,  0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   1,   0,   1,   0,   1,   0,   0 ][q]


*/

bool isWithinCapacity(int w, int q, int y, int z) {
	return (w + q + y + z) * 7 / 3  <= 1111;
}

bool isValidValue(unordered_set<int> &storeCurrentValues, int valueToCheck) {
	if (storeCurrentValues.find(valueToCheck) != storeCurrentValues.end() || valueToCheck <= 0) {
		return false;
	}
	return true;
}

bool comparator(vector<int> a, vector<int> b) {
	int sumA = 0;
	int sumB = 0;
	for (int i = 0; i < 28; i++) {
		sumA += a[i];
		sumB += b[i];
	}
	return sumA < sumB;
}

/*
	The above finds the minimum assuming all blocks are magic.
	After obtaining all magic, next would be to do minor optimisations
	by making some as almost magic to reduce grid sum.
*/
int main() {
	// { wN, wD, qN, qD, yN, yD, zN, zD }
	// Using Gaussian elimination on the matrix we get the expressions below
	vector<vector<int>> conds = {
		{1, 3, -1, 3, 2, 3, -1, 3},
		{ -1, 3, 2, 3, -1, 1, 1, 1},
		{0, 1, -1, 3, 1, 3, 1, 3},
		{ -1, 3, 0, 1, -1, 3, 1, 1},
		{0, 1, 0, 1, 0, 1, 1, 3},
		{1, 3, 0, 1, 1, 3, -1, 3},
		{0, 1, 1, 3, -1, 3, 1, 3},
		{1, 3, -2, 3, 1, 1, -1, 3},
		{ -1, 3, 1, 3, -2, 3, 1, 1},
		{ -1, 3, 1, 3, 1, 3, 0, 1},
		{2, 3, -1, 1, 1, 1, -1, 3},
		{0, 1, 0, 1, 1, 3, 0, 1},
		{ -2, 3, 1, 1, -1, 3, 1, 3},
		{ -1, 3, 2, 3, -1, 3, 1, 3},
		{0, 1, -1, 3, 1, 1, -1, 3},
		{1, 3, -1, 3, 1, 3, 0, 1},
		{1, 1, -1, 3, 0, 1, -1, 3},
		{ -1, 3, 1, 3, -1, 3, 2, 3},
		{1, 3, 0, 1, 0, 1, 0, 1},
		{1, 1, -1, 3, 2, 3, -1, 1},
		{1, 1, -1, 3, 1, 3, -2, 3},
		{ -1, 3, 1, 3, 0, 1, 1, 3},
		{1, 3, 0, 1, -1, 3, 1, 3},
		{0, 1, 1, 3, 0, 1, 0, 1},
		{ -1, 3, 1, 1, -1, 3, 0, 1},
		{1, 3, 1, 3, 0, 1, -1, 3},
		{ -1, 1, 1, 1, -1, 3, 2, 3},
		{2, 3, -1, 3, 1, 3, -1, 3}
	};
	vector<vector<int>> allWays;
	for (int w = 15; w <= 480; w += 3) {
		for (int q = 15; q <= 480; q += 3) {
			for (int y = 15; y <= 480; y += 3) {
				for (int z = 15; z <= 480; z += 3) {
					if (!isWithinCapacity(w, q, y, z)) {
						continue;
					}
					unordered_set<int> storeCurrentValues;
					vector<int> possibleValues;
					bool isFailure = false;
					for (vector<int> cond : conds) {
						int value = cond[0] * w / cond[1] + cond[2] * q / cond[3] + cond[4] * y / cond[5] + cond[6] * z / cond[7];
						if (!isValidValue(storeCurrentValues, value)) {
							isFailure = true;
							break;
						}
						storeCurrentValues.insert(value);
						possibleValues.push_back(value);

					}
					if (!isFailure) {
						allWays.push_back(possibleValues);
					}

				}
			}
		}
	}
	sort(allWays.begin(), allWays.end(), comparator);
	if (allWays.size() > 0) {
		int sum = 0;
		for (int v : allWays[0]) {
			cout << v << ' ';
			sum += v;
		}
		cout << '\n';
		cout << "Sum total: " << sum << '\n';
	}
}